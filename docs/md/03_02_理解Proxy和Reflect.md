# 04_理解Proxy和Reflect

### 开始之前:

为什么还会有这一篇文章呢？  
不是手写mini-vue吗？其实可以理解成支线任务、番外篇，是对主线内容的补充。

这一篇文章可能文字比较多，理论知识比较多，参考了4本书相关的章节写的，可以泡杯咖啡或者喝杯茶，坐下来慢慢看哦。

### 为什么使用Proxy？

众所周知，`vue3`的响应式是靠代理对象实现的。

代理是使用`Prox`构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出TypeError。

使用代理的主要目的是可以定义捕获器（trap）。  
捕获器就是在处理程序对象中定义的“基本操作的拦截器”。

每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。  
每次在代理对象上调用这些基本操作就时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。

既然我们知道了为什么用`Proxy`，那接下来就来看看`Proxy`到底是什么？

### Proxy是什么？

> 《ES6标准入门》
>
> Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于 种“元编程”（ meta programming ），即对编程语言进行编程。
>
> Proxy 可以理解成在目标对象前架设 个“拦截”层 ，外界对该对象的访问都必须先通过 这层拦截，因此提供了一种机制可以对外界的访问进行过滤和改写。
>
> Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。


> 《深入理解ES6》
>
> 通过调用 new Proxy() ，你可以创建一个代理用来替代另一个对象（被称为目标），这个代理对目标对象进行了虚拟，因此该代理与该目标对象表面上可以被当作同一个对象来对待。
>
> 代理允许你拦截在目标对象上的底层操作，而这原本是 JS 引擎的内部能力。拦截行为使用了一个能够响应特定操作的函数（被称为陷阱）。


> 《JavaScript高级程序设计（第4版）》
>
> ECMAScript 6
> 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。
>
> 从很多方面看，代理类似 C++指针，因为它可以用作目标对象的替身，但又完全独立于目标对象。目标对象既可以直接被操作，也可以通过代理来操作。
> 但直接操作会绕过代理施予的行为。

从以上书籍中的描述，我们可以大概总结一下：使用 `Proxy` 可以创建一个代理对象，它能够实现对 `其他对象` 的代理。

这里的关键词有两个：

1. **“创建”** ： 意为代理对象这是一个新对象。
2. **“其他对象”** ： 只能代理对象，无法代理非对象值，例如：数字、字符串、布尔类型。

那么，代理指的是什么呢？

所谓代理，指的是对一个对象基本语义的代理。它允许我们拦截并重新定义对一个对象的基本操作。  
这句话的关键词比较多，我们逐一解释。

前文也提到了基本操作，这里又说到了基本语义，那么什么样的才是基本的呢？

```ts
const obj = { foo: 1 };

obj.foo; // 读取属性 foo 的值
obj.foo++; // 读取和设置属性 foo 的值
```

给出一个对象，我们可以读取某个属性的值，同样也可以设置某个属性的值。

类似这种读取、设置属性值的操作，就属于基本语义的操作，即`基本操作`。当然，勿6！

既然是基本操作，那么它就可以使用`Proxy`拦截：

```ts
const p = new Proxy(obj, {
  // 拦截读取属性操作
  get() { /*...*/ },
  // 拦截设置属性操作
  set() { /*...*/ }
})
```

这里，又回到上面说的了，
